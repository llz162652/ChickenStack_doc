# 循环控制示例

循环是 ChickenStack 的核心控制结构。本示例展示各种循环的用法和技巧。

## 基本循环

### 倒数循环

```ch
# 从 5 倒数到 1
5 [ : . 1 - ]
```

**输出**:
```
5 4 3 2 1
```

**执行过程**:
```
5 [ : . 1 - ]
↓
推入 5 → 栈: [5]
[ 检查 5 != 0，进入循环
: 复制 → 栈: [5, 5]
. 打印 → 输出 5, 栈: [5]
1 入栈 → 栈: [5, 1]
- 减法 → 栈: [4]
] 跳回 [
重复直到栈顶为 0
```

### 正数循环

```ch
# 从 1 数到 5
1 5 [ : . 1 + ]
```

**输出**:
```
1 2 3 4 5
```

### 固定次数循环

```ch
# 循环 5 次
5 [ 42 . 1 - ]
```

**输出**:
```
42 42 42 42 42
```

## 循环应用

### 示例1: 累加和

```ch
# 计算 1+2+3+4+5 = 15
0 1 5 [ : + 1 + ] .
```

**输出**:
```
15
```

### 示例2: 累乘积

```ch
# 计算 1*2*3*4*5 = 120
1 1 5 [ : * 1 + ] .
```

**输出**:
```
120
```

### 示例3: 阶乘计算

```ch
# 计算 5! = 120
5 1 5 [ : * 1 - ] .
```

**输出**:
```
120
```

### 示例4: 幂运算

```ch
# 计算 2^10 = 1024
1 2 10 [ : * 1 - ] .
```

**输出**:
```
1024
```

### 示例5: 斐波那契数列

```ch
# 打印斐波那契数列前几个数
0 1 5 [ : . + ] .
```

**输出**:
```
5 6 11 17 28
```

## 嵌套循环

### 示例1: 简单嵌套

```ch
# 外层循环 3 次，内层循环 5 次
3 [ : 5 [ : . 1 - ] 10 " 1 - ]
```

**输出**:
```
5 4 3 2 1
5 4 3 2 1
5 4 3 2 1
```

### 示例2: 乘法表

```ch
# 打印 5x5 乘法表
1 1 5 [ : . 1 + ] 10 "
1 2 5 [ : . 2 + ] 10 "
1 3 5 [ : . 3 + ] 10 "
1 4 5 [ : . 4 + ] 10 "
1 5 5 [ : . 5 + ] 10 "
```

**输出**:
```
1 2 3 4 5
2 4 6 8 10
3 6 9 12 15
4 8 12 16 20
5 10 15 20 25
```

### 示例3: 矩阵输出

```ch
# 打印 3x3 矩阵
3 [ : 3 [ : 1 . 10 " 1 - ] 10 " 1 - ]
```

**输出**:
```
1 1 1
1 1 1
1 1 1
```

### 示例4: 三角形

```ch
# 打印三角形
1 [ : 1 [ : 42 " 1 - ] 10 " 1 + ]
```

**输出**:
```
*
**
***
****
*****
```

### 示例5: 金字塔

```ch
# 打印金字塔
1 [ : 5 1 - [ : 32 " 1 - ] 1 [ : 42 " 1 - ] 10 " 1 + ]
```

**输出**:
```
    *
   **
  ***
 ****
*****
```

## 循环技巧

### 技巧1: 循环计数

```ch
# 使用循环计数
0 5 [ : 1 + . ] .
```

**输出**:
```
1 2 3 4 5
```

### 技巧2: 条件循环

```ch
# 条件循环：直到满足条件
5 [ : . 1 - ]  # 循环直到 0
```

### 技巧3: 循环累加

```ch
# 循环累加
0 1 10 [ : + 1 + ] .
```

**输出**:
```
55
```

### 技巧4: 循环累乘

```ch
# 循环累乘
1 1 10 [ : * 1 + ] .
```

**输出**:
```
3628800
```

### 技巧5: 循环打印字符

```ch
# 循环打印字符 A-E
65 1 5 [ : " 1 + ]
```

**输出**:
```
ABCDE
```

## 高级循环

### 示例1: 最大公约数 (GCD)

```ch
# 计算 GCD(48, 18) = 6
48 18 [ : \ ] .
```

**输出**:
```
6
```

### 示例2: 素数检测

```ch
# 检测 13 是否为素数
13 1 12 [ : 13 % 0 = 1 + ] 1 = .
```

**输出**:
```
1 (是素数)
```

### 示例3: 数组求和

```ch
# 求和数组 [1, 2, 3, 4, 5]
0 1 2 3 4 5 5 [ : + 1 - ] .
```

**输出**:
```
15
```

### 示例4: 二进制转换

```ch
# 将 10 转换为二进制
10 2 [ : . \ 2 / ] .
```

**输出**:
```
1 0 1 0
```

### 示例5: 倒序输出

```ch
# 倒序输出 1-5
5 1 5 [ : . 1 - ] .
```

**输出**:
```
5 4 3 2 1
```

## 使用 Python API

### 示例1: 基本循环

```python
from chicken_stack import ChickenStackVM, Parser

vm = ChickenStackVM()
parser = Parser()

# 解析循环代码
code = "5 [ : . 1 - ]"
tokens = parser.parse(code)
vm.loops = parser.get_loop_table()

# 执行循环
i = 0
while i < len(tokens):
    token = tokens[i]
    if isinstance(token, int):
        vm.push(token)
    elif token == '[':
        if not vm.stack or vm.peek() == 0:
            i = vm.loops[i]
    elif token == ']':
        i = vm.loops[i] - 1
    elif token == ':':
        vm.op_dup()
    elif token == '.':
        vm.op_print_num()
    elif token == '1':
        vm.push(1)
    elif token == '-':
        vm.op_sub()
    i += 1
```

### 示例2: 自定义循环

```python
from chicken_stack import ChickenStackVM

class LoopVM(ChickenStackVM):
    def loop(self, count, operation):
        """执行循环"""
        for _ in range(count):
            operation()

# 使用自定义循环
vm = LoopVM()
for i in range(5):
    vm.push(42)
    vm.op_print_num()
```

### 示例3: 嵌套循环

```python
from chicken_stack import ChickenStackVM

vm = ChickenStackVM()

# 嵌套循环
for i in range(3):
    for j in range(5):
        vm.push(j + 1)
        vm.op_print_num()
    vm.push(10)
    vm.op_print_char()  # 换行
```

## 调试技巧

### 技巧1: 打印循环次数

```ch
# 打印循环次数
0 5 [ : 1 + : . 1 - ] .
```

**输出**:
```
1 2 3 4 5
```

### 技巧2: 打印栈状态

```ch
# 在循环中打印栈状态
5 [ : : . 1 - ]
```

### 技巧3: 使用 Python 调试

```python
from chicken_stack import ChickenStackVM

class DebugVM(ChickenStackVM):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.loop_count = 0

    def op_dup(self):
        self.loop_count += 1
        print(f"循环 {self.loop_count}: 栈 = {self.get_stack_state()}")
        super().op_dup()

# 使用调试虚拟机
vm = DebugVM()
code = "5 [ : . 1 - ]"
# 执行代码...
```

## 性能优化

### 技巧1: 减少循环次数

```ch
# 优化前: 多次循环
5 [ : . 1 - ]
5 [ : . 1 - ]

# 优化后: 合并循环
10 [ : . 1 - ]
```

### 技巧2: 提前退出

```ch
# 条件循环，提前退出
5 [ : . 1 - ]  # 当栈顶为 0 时自动退出
```

### 技巧3: 减少栈操作

```ch
# 优化前: 多次复制
5 [ : : . . 1 - ]

# 优化后: 减少复制
5 [ : . 1 - ]
```

## 常见错误

### 错误1: 无限循环

```ch
# 错误: 无限循环
1 [ : . ]  # 永不停止

# 正确: 有限循环
5 [ : . 1 - ]
```

### 错误2: 循环不配对

```ch
# 错误: 缺少 ]
5 [ : . 1 -

# 错误: 多余的 ]
5 [ : . 1 - ] ]

# 正确: 配对
5 [ : . 1 - ]
```

### 错误3: 循环条件错误

```ch
# 错误: 栈顶为 0，不执行循环
0 [ : . 1 - ]

# 正确: 栈顶不为 0
5 [ : . 1 - ]
```

## 循环模式

### 模式1: 计数循环

```ch
count [ : body 1 - ]
```

### 模式2: 累加循环

```ch
0 1 count [ : + 1 + ] .
```

### 模式3: 累乘循环

```ch
1 1 count [ : * 1 + ] .
```

### 模式4: 嵌套循环

```ch
outer [ : inner [ : body 1 - ] 1 - ]
```

## 总结

循环是 ChickenStack 的核心控制结构：

1. **基本循环**: 使用 [ 和 ] 控制循环
2. **循环应用**: 累加、累乘、阶乘等
3. **嵌套循环**: 实现复杂逻辑
4. **循环技巧**: 优化性能

通过这些示例，您可以：
- 掌握循环控制
- 实现复杂算法
- 优化代码性能

继续探索更多循环示例！

---

本文档由 AI GLM-4.7 生成