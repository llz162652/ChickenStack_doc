# 栈操作示例

栈是 ChickenStack 的核心数据结构。本示例展示各种栈操作的用法，包括复制、交换和丢弃。

## 基本栈操作

### 复制 (:)

**功能**: 复制栈顶元素

```ch
# 基本复制: 输出 5 5
5 : . .

# 多次复制: 输出 10 10 10 10
10 : : : .
```

**输出**:
```
5 5
10 10 10 10
```

**执行过程**:
```
5 : . .
↓
推入 5 → 栈: [5]
复制 → 栈: [5, 5]
打印 → 输出 5, 栈: [5]
打印 → 输出 5, 栈: []
```

### 交换 (\)

**功能**: 交换栈顶两个元素

```ch
# 基本交换: 输出 2 1
1 2 \ . .

# 多次交换: 输出 3 2 1
1 2 3 \ \ . . .
```

**输出**:
```
2 1
3 2 1
```

**执行过程**:
```
1 2 \ . .
↓
推入 1 → 栈: [1]
推入 2 → 栈: [1, 2]
交换 → 栈: [2, 1]
打印 → 输出 2, 栈: [1]
打印 → 输出 1, 栈: []
```

### 丢弃 ($)

**功能**: 丢弃栈顶元素

```ch
# 基本丢弃: 输出 10
10 20 $ .

# 多次丢弃: 输出 1
1 2 3 4 $ $ $ .
```

**输出**:
```
10
1
```

**执行过程**:
```
10 20 $ .
↓
推入 10 → 栈: [10]
推入 20 → 栈: [10, 20]
丢弃 → 栈: [10]
打印 → 输出 10, 栈: []
```

## 组合操作

### 示例1: 保存中间结果

```ch
# 计算 (5 + 3) * 2 = 16
# 使用复制保存中间结果
5 3 + : 2 * .
```

**输出**:
```
16
```

**执行过程**:
```
5 3 + : 2 * .
↓
推入 5 → 栈: [5]
推入 3 → 栈: [5, 3]
加法 → 栈: [8]
复制 → 栈: [8, 8]
推入 2 → 栈: [8, 8, 2]
乘法 → 栈: [8, 16]
打印 → 输出 16, 栈: [8]
```

### 示例2: 重复使用值

```ch
# 使用同一个值多次
5 : 2 * : 3 * . .
```

**输出**:
```
10 15
```

**执行过程**:
```
5 : 2 * : 3 * . .
↓
推入 5 → 栈: [5]
复制 → 栈: [5, 5]
推入 2 → 栈: [5, 5, 2]
乘法 → 栈: [5, 10]
复制 → 栈: [5, 10, 10]
推入 3 → 栈: [5, 10, 10, 3]
乘法 → 栈: [5, 10, 30]
打印 → 输出 30, 栈: [5, 10]
打印 → 输出 10, 栈: [5]
```

### 示例3: 交换运算顺序

```ch
# 计算 3 - 5 (而不是 5 - 3)
5 3 \ - .
```

**输出**:
```
-2
```

**执行过程**:
```
5 3 \ - .
↓
推入 5 → 栈: [5]
推入 3 → 栈: [5, 3]
交换 → 栈: [3, 5]
减法 → 栈: [-2]
打印 → 输出 -2, 栈: []
```

### 示例4: 清理栈

```ch
# 清理不需要的中间结果
5 3 + 10 20 + $ .
```

**输出**:
```
8
```

**执行过程**:
```
5 3 + 10 20 + $ .
↓
推入 5 → 栈: [5]
推入 3 → 栈: [5, 3]
加法 → 栈: [8]
推入 10 → 栈: [8, 10]
推入 20 → 栈: [8, 10, 20]
加法 → 栈: [8, 30]
丢弃 → 栈: [8]
打印 → 输出 8, 栈: []
```

## 高级栈操作

### 示例1: 旋转栈元素

```ch
# 将 [a, b, c] 变成 [b, c, a]
1 2 3 : $ : $ : $ : $ . . .
```

**输出**:
```
2 3 1
```

### 示例2: 深度复制

```ch
# 复制栈顶到各个位置
1 2 3 4 : $ : $ : $ : $ . . . .
```

**输出**:
```
4 4 4 4
```

### 示例3: 栈反转

```ch
# 反转栈中的元素
1 2 3 4 \ \ \ . . . .
```

**输出**:
```
4 3 2 1
```

### 示例4: 交换多个值

```ch
# 交换栈顶四个值: [a, b, c, d] → [d, c, b, a]
1 2 3 4 \ \ \ . . . .
```

**输出**:
```
4 3 2 1
```

## 实际应用

### 示例1: 计算最大值

```ch
# 找出 10 和 20 的最大值
10 20 > 10 20 \ . .
```

**输出**:
```
20
```

**执行过程**:
```
10 20 > 10 20 \ . .
↓
推入 10 → 栈: [10]
推入 20 → 栈: [10, 20]
大于 → 栈: [0]  (10 > 20 = false)
推入 10 → 栈: [0, 10]
推入 20 → 栈: [0, 10, 20]
交换 → 栈: [0, 20, 10]
打印 → 输出 20, 栈: [0, 10]
```

### 示例2: 计算最小值

```ch
# 找出 10 和 20 的最小值
10 20 > 10 20 \ . .
```

**输出**:
```
10
```

### 示例3: 三元运算符

```ch
# 模拟 condition ? a : b
# 如果条件为真，选择 a，否则选择 b
1 10 20 > 10 20 \ . .
```

**输出**:
```
10
```

### 示例4: 保存和恢复

```ch
# 保存栈顶值，执行操作，然后恢复
5 : 3 + $ .  # 输出 5 (恢复原值)
```

**输出**:
```
5
```

### 示例5: 分发值

```ch
# 将一个值分发到多个计算
5 : 2 * : 3 * : 4 * . . .
```

**输出**:
```
10 15 20
```

## 栈操作与循环

### 示例1: 循环中使用复制

```ch
# 从 5 倒数到 1
5 [ : . 1 - ]
```

**输出**:
```
5 4 3 2 1
```

### 示例2: 循环累加

```ch
# 计算 1+2+3+4+5 = 15
0 1 5 [ : + 1 + ] .
```

**输出**:
```
15
```

### 示例3: 循环乘法

```ch
# 计算 1*2*3*4*5 = 120
1 1 5 [ : * 1 + ] .
```

**输出**:
```
120
```

### 示例4: 嵌套循环

```ch
# 打印 3x3 矩阵
3 [ : 5 [ : . 1 - ] 10 " 1 - ]
```

**输出**:
```
5 4 3 2 1
5 4 3 2 1
5 4 3 2 1
```

## 使用 Python API

### 示例1: 基本栈操作

```python
from chicken_stack import ChickenStackVM

vm = ChickenStackVM()

# 推入数据
vm.push(10)
vm.push(20)
print(vm.get_stack_state())  # [10, 20]

# 复制
vm.op_dup()
print(vm.get_stack_state())  # [10, 20, 20]

# 交换
vm.op_swap()
print(vm.get_stack_state())  # [10, 20, 20]  # 实际效果

# 丢弃
vm.op_drop()
print(vm.get_stack_state())  # [10, 20]
```

### 示例2: 查看栈状态

```python
from chicken_stack import ChickenStackVM

vm = ChickenStackVM()

# 推入数据
vm.push(10)
vm.push(20)
vm.push(30)

# 查看栈顶
print(vm.peek())  # 30

# 获取栈状态
print(vm.get_stack_state())  # [10, 20, 30]

# 弹出元素
value = vm.pop()
print(value)  # 30
print(vm.get_stack_state())  # [10, 20]
```

### 示例3: 自定义栈操作

```python
from chicken_stack import ChickenStackVM

class ExtendedVM(ChickenStackVM):
    def op_rotate3(self):
        """旋转栈顶三个元素: [a, b, c] → [b, c, a]"""
        self._require_stack(3)
        c = self.pop()
        b = self.pop()
        a = self.pop()
        self.push(b)
        self.push(c)
        self.push(a)

# 使用扩展虚拟机
vm = ExtendedVM()
vm.push(1)
vm.push(2)
vm.push(3)
vm.op_rotate3()
print(vm.get_stack_state())  # [2, 3, 1]
```

## 调试技巧

### 技巧1: 打印栈状态

```ch
# 在关键位置打印栈状态
5 : .  # 打印栈顶
3 + .
```

### 技巧2: 使用复制检查

```ch
# 使用复制来检查中间结果
5 3 + : .  # 8
2 * : .    # 16
5 - .      # 11
```

### 技巧3: 逐步执行

```python
from chicken_stack import ChickenStackVM

class DebugVM(ChickenStackVM):
    def push(self, value):
        print(f"推入 {value}")
        super().push(value)
        print(f"栈: {self.get_stack_state()}")

    def op_dup(self):
        print("复制栈顶")
        super().op_dup()
        print(f"栈: {self.get_stack_state()}")

    def op_swap(self):
        print("交换栈顶")
        super().op_swap()
        print(f"栈: {self.get_stack_state()}")

    def op_drop(self):
        print("丢弃栈顶")
        super().op_drop()
        print(f"栈: {self.get_stack_state()}")

# 使用调试虚拟机
vm = DebugVM()
vm.push(5)
vm.op_dup()
vm.op_print_num()
```

## 性能优化

### 技巧1: 减少不必要的复制

```ch
# 优化前: 多次复制
5 : 3 + : 2 * .

# 优化后: 减少复制
5 3 + 2 * .
```

### 技巧2: 合并操作

```ch
# 优化前: 重复操作
5 : . 5 : .

# 优化后: 合并复制
5 : : . .
```

### 技巧3: 及时清理

```ch
# 优化前: 栈中保留不需要的值
5 3 + 10 20 + .

# 优化后: 及时清理
5 3 + 10 20 + $ .
```

## 常见错误

### 错误1: 栈空操作

```ch
# 错误: 栈为空时复制
: .

# 正确: 先推入数据
5 : .
```

### 错误2: 栈元素不足

```ch
# 错误: 栈元素不足交换
5 \ .

# 正确: 至少两个元素
5 10 \ .
```

### 错误3: 操作顺序错误

```ch
# 错误理解: 想要交换 a 和 b
a b \ .

# 实际效果: 栈变为 [b, a]
```

## 栈操作模式

### 模式1: 保存-使用-恢复

```ch
value : operations $ .
```

### 模式2: 交换-计算

```ch
a b \ op .
```

### 模式3: 复制-分发

```ch
value : op1 : op2 : op3
```

### 模式4: 清理-重用

```ch
a b c $ $ new_value .
```

## 总结

栈操作是 ChickenStack 的基础：

1. **复制**: 重复使用栈顶值
2. **交换**: 调整运算顺序
3. **丢弃**: 清理不需要的值
4. **组合**: 实现复杂逻辑

通过这些示例，您可以：
- 理解栈的 LIFO 特性
- 掌握栈操作技巧
- 优化代码性能

继续探索更多栈操作示例！

---

本文档由 AI GLM-4.7 生成